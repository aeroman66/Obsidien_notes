# 编译流程
src文件夹中包含1个脚本：
	源代码中的注释可能变成乱码，可以看后面的算法流程部分。
1. main.c 
## 编译
1. 进入build目录执行cmake ..命令
2. 然后在同一目录下执行make命令。得到的可执行文件在"/Homework04/build/bin" 当中，为"main.exe"
# 算法流程
解释代码原理。
1. 将目标地址的第一个字节地址传给一个新指针作为函数的返回值。因为在后面的操作中，原本传入的地址需要进行迭代，不再指向目标地址第一字节，由此我们需要做出备份。
![[memory_demo]]
2. 我们将原地址中的内容一字节一字节的拷贝到新地址中，通过指针的迭代完成。
	我们仅讨论了正常情况下拷贝应如何完成，还没讨论内存溢出的情况。
## 溢出原因分析
	这一部分主要解释溢出
算上结束标记位，我们有一个长度为11的字符串需要通过**strcpy**进行复制。但是我们的目标内存块长度在开辟的开始就被指定，长度为8，超出八的部分，可能目前是闲置状态，也可能目前正被计算机拿来存储其他数据，如下图所示。
当我们向目标内存复制内容时，尽管预留的内存已经用完了，但是很显然我们的东西并没有复制完。于是，在没有预防手段的情况下，我们的计算机擅自使用了其后连续的并未被预留的部分。
**内存溢出**的情况发生了，若原本被侵占的内存存放了重要数据，那么这样的行为会有严重的后果。
![[memory_overflow]]

## 溢出解决方案
我们的解决方案很简单粗暴。
往函数中多传入一个参数，内容是目标内存的长度。函数本身对每次复制操作进行计数，当他发现内存还剩一字节用完的时候，就停止复制，往目标字符串末尾加上结束标识符。并返回这个结果。
当然，若内存长度足够，就会正常的完成整个复制过程。