# 变量 Variable
## 定义
为程序提供一个具名的、可操作的存储空间。每个变量都有数据类型，决定其所占内存空间大小和布局方式、能存储的值的范围以及可以参与的运算。（variable,object）
## 变量定义形式

类型说明符+一个或多个变量名组成列表。（, ;）
### 初始值
- 初始化：创建变量时给其一个特定的值。
- 可以用先定义的变量去初始化其他变量。
tip：初始化与赋值的区别：（有时候这个区别会比较重要）
初始化：创建变量时赋予其初始值。
赋值：擦除对象当前值，用新值将其代替。

#### 四种初始化方式：
int unit = 0;
int unit = {0};
int unit{0};
int unit(0);

##### 列表初始化
用花括号的初始化{}。
用于内置变量类型时，初始值存在信息丢失风险，编译器将报错。

##### 默认初始化
定义变量时未指定初始值。
tip：对于内置类型，若变量定义于任何函数体外，初始化为零。若定义于函数体内，则不被初始化，访问或拷贝它会引发错误。

### 声明和定义的关系
C++支持分离式编译：将程序分成若干文件，每个可被独立编译。
- 声明：使得名字为程序所知。
	- 规定类型和名字
	- extern int i;
- 定义：创建与名字关联的实体。
	- 规定类型和名字（与声明共同点）
	- 申请存储空间
	- 为变量赋初始值
tip:
- 声明变量千万不能显性初始化这个变量，否则extern的作用会被直接的抵消，变成一条定义。
- 变量只能定义一次，但是可以声明多次。
#### 静态类型
在编译阶段检查类型。
编译器在知道变量类型后，才可以判断该变量能否参加某种运算，所以使用变量前必须声明其类型。

## 标识符（变量名称）
字母、数字和下划线组成。字母或下划线开头，大小写敏感。
tips：
- 不能出现连续两个下划线
- 不能下划线紧邻大写字母开头
- 函数体外标识符不能下划线开头

## 名字作用域
大部分作用域以花括号分隔，是程序的一部分，在其中的名字有其特别的含义。
- 同一名字在不同作用域中可以指向不同实体
- 名字有效区域始于声明语句，结束于申明语句所在作用域末
#### 全局作用域
整个程序范围内可使用（eg：main）
#### 块作用域
### 嵌套的作用域
- _外层作用域_ 可以被它所有的内层作用域访问。
- _内层作用域_ 可以重新定义外层作用域的名字。

# 基本内置类型
## 两大类
### 空类型 void
不对应具体值，只用于一些特殊场合。
例如：作为不返回任何值的函数的返回类型
### 算术类型 arithmetic type
包含了很多类变量
notions：
- 字节Byte：可寻址的最小内存块
- 字Word：存储的基本单元
### 整形
- Bool：true、false
- char：一个字符的空间应确保可以存放机器基本字符集中任意字符对应的数字值。
- short,int,long,long long
tip：除了布尔和拓展字符型以外，其他整型可以划分为两种
- signed
- unsigned
(char,signed char,unsigned char)
### 浮点型
- float
- double
- long double

## 类型转换 Convert
tip：避免无法预知和依赖于实现环境的行为
- _不可移植的_ 程序
不要混用无符号类型和有符号类型
- 有符号类型会自定转化成无符号类型

# 复合类型
	我们将要介绍的两种复合类型都实现了对对象的间接访问。
基于其他类型定义的类型。
基本数据类型+声明符（declarator）（命名一个变量并为其指定一个与基本数据类型有关的某种类型）
## 引用
	存在左值引用与右值引用的区别
- 给对象起另外一个名字，不会新分配内存空间，无法定义引用的引用，因为它本身不是对象。
- 会跟初始值一直绑定在一起，不能更改。也因此必须初始化。
- 不能跟字面值或者某个表达式的计算结果绑定在一起。

## 指针
	一些区别
- 指针本身是一个对象，允许赋值和拷贝
- 无需赋初值，未初始化的情况和内置类型一样
- 声明时指针指向的类型一定要和所指向的对象类型匹配
基本用法：
double \*pd = &dval
	指针存放的是某个对象的地址，要用取址符&去获取对象的地址
cout<<\*pd
	\*作为解引用符，获取指针指向对象（注意获取的不是指向对象的值！！！）
int \*pd = nullptr
	最推荐的定义空指针方法，也可以用 = 0

彩蛋：void \* 指针

## 复合类型的声明有点搞
	两种写法
int \*pd
	跟变量名写在一起，强调变量具有复合类型
int\* pd
	把修饰符跟类型名写一起，并且每行只定义一个变量，，强调我们定义了一种复合类型。
int i = 1024, \*p = &i, &r = i;
	合法
*阅读复杂的指针或引用声明时，从右往左阅读会有帮助，离变量名最近的符号有最直接的影响*
eg：\*\*pi, \*&re,\* const ptr

# const 限定符
	 默认状况下，const只在文件内有效，若多个文件中出现了同名const变量，那么其实相当于分别定义了独立变量。若要共享，则在其不管声明还是定义之前全部加上extern关键词。（原因有待理解，没有看懂）
## 常量引用
	对const的引用，仅对引用可参与的操作做出限定，对引用对象本身不做限定。
允许常量引用绑定非常量对象，不允许非常量引用绑定常量对象。

## 指针
	有指向常量的指针和常量指针之分
- 顶层const：指针本身是个常量
- 底层const：指针所指向的对象是一个常量 
更一般的来讲，顶层const可以表示任意对象是常量（如基本内置类型），底层const则与复合类型中的基本类型部分有关。指针可以同时是两种xonst，这是它与其他类型的区别。
### 指向常量的指针
	const int \*ptr
跟常量引用比较类似，只是不能通过该指针改变所指对象的值。
### 常量指针
	int \*const int ptr
本身是一个常量，必须初始化。自己所存储的地址在初始化完成后就不能改变了。

tip:
- 对常量的引用是常量引用
- 对常量的指针不是常量指针
- 原因在于引用本身不是对象，而指针本身是一个对象

## constexpr&常量表达式
### 常量表达式
	值不会改变且在编译阶段就能得到计算结果的表达式。
#### 字面值常量
一望而知，他的形式和值决定了它的数据类型。
- 整型与浮点型
	- 整型：默认带符号数，int,long,long long中能塞下的最小的那个（八进制十六进制不太一样）
	- 浮点型：默认double
- 字符和字符串字面值
	- char：‘a’
	- string：“Hello world”+“\0”
- 布尔字面值
	- true,false
- 转义序列
	- 不可打印的（没有可视化图表）
	- 在C++语言中有特殊含义的字符
- 指定字面值类型
	- 依据不同的变量类型而不同
#### 用常量表达式初始化的const对象
### constexpr变量
- 将变量声明成一个常量
- 验证变量的值是不是一个常量表达式

# 处理类型的几种方法
	让程序跟好理解，有时更好拼写。
## 类型别名
- typedef：作为基本数据类型的一部分出现。定义类型别名时声明符同样可包含修饰符。
- using IS = Sales_item;
tip:注意类型别名对顶层和底层const有意想不到的作用。
## auto类型说明符
通过初始值来判断变量类型。所以auto定义的变量必须得有初始值。
auto声明语句也可以同时声明多个变量，但一个声明语句只能有一个基本数据类型，所以该语句中所有初始基本数据类型都必须一样。
## decltype类型指示符
返回操作数的数据类型，可以不用操作数来初始化变量。
tip：与引用有奇妙的互动。