	本部分主要讲了有无约束 MPC 的区别，而没有着重讲具体如何在数学的角度处理约束，直接上 Matlab。
为什么约束？因为现实生活中处处存在约束！
MPC 是结合了优化方法的反馈控制：
$$
\text{MPC} = \text{optimization} + \text{feedback control}
$$
而在优化的过程中我们就可以将情况分为无条件极值和条件极值。对于条件极值，即有约束的情况下：
- 等式约束
好办，在后面加上拉格朗日乘子，还可以获得解析解：
$$
u^{*} = \arg\min_{u} f^{T}u + u^{T}Hu, t.q. A_{eq}u = b_{eq}
$$
$$
[u^{*}, \lambda^{*}] = \arg \min_{u,\lambda} f^{T} u + u^{T}Hu + \lambda(A_{eq}u - b_{eq})
$$
- 不等式约束
$$
Au \le b
$$
当解落在某个约束范围内时，相当于这个约束没有起作用。当解落在某个约束范围外时，相当于这个不等式约束变成了等式约束。

# 常见约束类型
- 凸约束（convexe）
两个例子：
方形约束：
$$
u_{i} \in U, \underline{u}_{i} \le u_{i} \le \bar{u}_{i}
$$
多面体约束
$$
A_{u}u \le b_{u}
$$
- 约束间耦合
$$
Gx + Hu \le 1
$$
上面的凸约束其实可以统一成这种情况，只需要令 G 或 H = 0 就行。

**Tip**:
感觉这里有必要讲一下一种矩阵转置写法，因为很容易搞错：
$$
X(k) \overset{\text{def}} = 
\begin{bmatrix}
x^{T}[1|k] & x^{T}[2|k] & \cdots & x^{T}[N|k]
\end{bmatrix}^{T}
$$
我们知道系统的状态向量或者控制向量都是列向量，搞清楚这点已经弄清楚了一大半：
$$
x[i|k] \in \mathcal{M}_{n \times 1}, X(k) \in \mathcal{M}_{nN \times 1}
$$

# 与无约束的区别
无约束解出的就是线性状态反馈，对于线性时不变系统来说，每一时刻解出来的反馈矩阵都是一样的，但是对于有约束 MPC 来说，解出来不一定是线性状态反馈，甚至可能没有固定的形式。所以我们可以将解出来的控制叫做 Control Policy，而其他的线性状态反馈，解出来的我们通常叫做 Control Law 控制律。
	感受一下 MPC 的独特之处
需要在线求解，计算量变大了。
## 优化可行性
感觉 ksj 可能会讲
凸优化总是可解的。

## 闭环系统稳定性
无约束情况下最优都不能保证系统是稳定的，所以有约束情况下更加不能保证系统的稳定性。
因为加了约束，事实上系统变成了一个非线性系统，我们要用李雅普诺夫函数的方法证明其稳定性。
### 保证稳定性机制
避免每次计算都要验证系统稳定性。
- 无限时域
- 终端等式约束
- 终端不等式约束
- 终端代价函数
会减弱系统的可控性